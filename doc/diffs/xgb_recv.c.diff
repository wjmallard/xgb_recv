--- xgb_recv/xgb_recv.c	2010-04-16 13:44:32
+++ PySPEAD/src/_spead/buffer_socket.cpp	2026-02-03 20:34:20
@@ -1,244 +1,202 @@
-/* file: xgb_recv.c
- * auth: William Mallard
- * mail: wjm@berkeley.edu
- * date: 2008-12-22
- */
+#include "include/buffer_socket.h"
 
-#include "xgb_recv.h"
+int default_callback(SpeadPacket *pkt, void *userdata) {
+    printf("    Readout packet with frame_cnt=%d, n_items=%d, payload_len=%d, payload_cnt=%d\n", 
+            pkt->frame_cnt, pkt->n_items, pkt->payload_len, pkt->payload_cnt);
+    return 0;
+}
 
-#define LISTEN_PORT 8888
-#define RX_BUFFER_SIZE 81920
-#define MAX_PAYLOAD_LEN 8192
-#define CAPTURE_FILE "raw_capture.dat"
+void init_buffer_socket(BufferSocket *bs, size_t item_count) {
+    // Initialize a BufferSocket
+    bs->buf = ring_buffer_create(item_count);
+    set_callback(bs, &default_callback);
+    bs->run_threads = 0;
+    bs->userdata = NULL;
+}
 
-/*
- * Wrapper for stand-alone testing.
- */
-int main(int argc, char **argv)
-{
-	return receive_packets();
+void free_buffer_socket(BufferSocket *bs) {
+    // Free all memory allocated for a BufferSocket
+    stop(bs);
+    if (bs->buf) ring_buffer_delete(bs->buf);
 }
 
-/*
- * Set up and spawn two threads.
- * net_thread writes data from the nic into a ring buffer.
- * hdd_thread reads data from a ring buffer to hard disk.
- * Wait for both threads to re-join.
- */
-int receive_packets()
-{
-	size_t buffer_size = RX_BUFFER_SIZE;
-	size_t list_length = RX_BUFFER_SIZE / MAX_PAYLOAD_LEN;
-	RING_BUFFER *pkt_buffer = ring_buffer_create(list_length, buffer_size);
+void set_callback(BufferSocket *bs, int (*cb_func)(SpeadPacket *, void *)) {
+    /* Set a callback function for handling data out of ring buffer */
+    bs->callback = cb_func;
+}
 
-	NET_THREAD_ARGS net_thread_args;
-	net_thread_args.pkt_buffer = pkt_buffer;
+int start(BufferSocket *bs, int port) {
+    /* Start socket => buffer and buffer => callback threads */
+    if (bs->run_threads != 0) {
+        fprintf(stderr, "BufferSocket already running.\n");
+        return 1;
+    }
+    bs->port = port;
+    bs->run_threads = 1;
+    pthread_create(&bs->net_thread, NULL, net_thread_function, bs);
+    pthread_create(&bs->data_thread, NULL, data_thread_function, bs);
+    return 0;
+}
 
-	HDD_THREAD_ARGS hdd_thread_args;
-	hdd_thread_args.pkt_buffer = pkt_buffer;
-
-	// start listening for Ctrl-C
-	//signal(SIGINT, cleanup);
-
-	// make stdout unbuffered
-	setbuf(stdout, NULL);
-
-	pthread_t net_thread, hdd_thread;
-	pthread_create(&net_thread, NULL, net_thread_function, &net_thread_args);
-	pthread_create(&hdd_thread, NULL, hdd_thread_function, &hdd_thread_args);
-
-	pthread_join(net_thread, NULL);
-	pthread_join(hdd_thread, NULL);
-
+int stop(BufferSocket *bs) {
+    /* Send halt signal for net/data threads, then join them */
+    if (!bs->run_threads) return 1;
+    bs->run_threads = 0;
+    pthread_join(bs->net_thread, NULL);
+    pthread_join(bs->data_thread, NULL);
 	return 0;
 }
 
-/*
- * Read data from the network.
- * Write data to ring buffer.
- */
-void *net_thread_function(void *arg)
-{
-	NET_THREAD_ARGS *args = (NET_THREAD_ARGS *)arg;
-	RING_BUFFER *pkt_buffer = args->pkt_buffer;
 
-	RING_ITEM *this_slot = pkt_buffer->write_ptr;
-	RING_ITEM *next_slot = NULL;
+void *data_thread_function(void *arg) {
+    /* This thread reads data out of a ring buffer through a callback */
+    BufferSocket *bs = (BufferSocket *)arg;
+    RING_ITEM *this_slot;
+    struct timespec ts;
+    int i;
 
-	socket_t sock = setup_network_listener();
-	void *buffer = NULL;
-	size_t length = MAX_PAYLOAD_LEN;
-	int flags = 0;
-	SA_in addr; // packet source's address
-	socklen_t addr_len = sizeof(addr);
-	ssize_t num_bytes = 0;
+    while (bs->run_threads) {
+        this_slot = bs->buf->read_ptr;
+        if (clock_gettime(CLOCK_REALTIME, &ts) == -1) {
+            fprintf(stderr, "Data: clock_gettime returned nonzero.\n");
+            bs->run_threads = 0;
+            continue;
+        }
+        ts.tv_nsec += 10000000;     // 10 ms
+        // Wait for next buffer slot to fill up
+        if (sem_timedwait(&this_slot->read_mutex, &ts) == -1) continue;
+         //printf("Reading in a packet: size=%d slot=%d\n", this_slot->size, this_slot - bs->buf->list_ptr);
+        // Feed data from buffer slot to callback function
+        // The callback steals the reference to pkt, and should free its memory when done
 
-	debug_fprintf(stderr, "Entering network thread loop.\n");
+        // Check if this packet has STREAM_CTRL set to STREAM_CTRL_VAL_TERM
+        for (i=0; i < this_slot->pkt.n_items; i++) {
+            if (this_slot->pkt.items[i].id == SPEAD_STREAM_CTRL_ID &&
+                    this_slot->pkt.items[i].val == SPEAD_STREAM_CTRL_TERM_VAL)
+                bs->run_threads = 0;
+        }
 
-	/*
-	 * loop forever:
-	 *   update relevant local pointers,
-	 *   wait for next free buffer slot,
-	 *   grab current buffer slot write_mutex,
-	 *   read data from network into the slot,
-	 *   release the buffer slot read_mutex,
-	 *   validate received data based on length,
-	 *   advance write pointer to next buffer slot.
-	 */
-	while (run_net_thread)
-	{
-		next_slot = this_slot->next;
-		buffer = this_slot->data;
-
-		sem_wait(&this_slot->write_mutex);
-		num_bytes = recvfrom(sock, buffer, length, flags, (SA *)&addr, &addr_len);
-		this_slot->size = num_bytes;
-		sem_post(&this_slot->read_mutex);
-
-		if (num_bytes == -1)
-		{
-			perror("Unable to receive packet.\n");
-			exit(1);
+        // Send packet to callback (even if it's a STREAM_CTRL TERM packet)
+        if (bs->callback(&this_slot->pkt, bs->userdata) != 0) {
+            fprintf(stderr, "Data: Callback returned nonzero.\n");
+            bs->run_threads = 0;
+        } else {
+            // Release this slot for writing
+            spead_free_packet(&this_slot->pkt);
+            sem_post(&this_slot->write_mutex);
+            bs->buf->read_ptr = this_slot->next;
 		}
-		else
-		{
-			debug_fprintf(stderr, "[net thread] Received %ld bytes.\n", num_bytes);
 		}
+    return NULL;
+}
 
-		this_slot = next_slot;
-	} // end while
+void *net_thread_function(void *arg) {
+    /* This thread puts data into a ring buffer from a socket*/
+    BufferSocket *bs = (BufferSocket *)arg;
+    RING_ITEM *this_slot;
 
-	debug_fprintf(stderr, "Exiting network thread loop.\n");
+    socket_t sock = setup_network_listener((short) bs->port);
+    //SA_in addr; // packet source's address
+    //socklen_t addr_len = sizeof(addr);
+    ssize_t num_bytes=0, bufoff=0;
+    int is_ready;
+    fd_set readset;
+    struct timeval tv;
+    struct timespec ts;
 
-	close(sock);
+    char buf[SPEAD_MAX_PACKET_SIZE];
+    int i;
 
-	run_hdd_thread = 0;
-
+    // If sock open fails, end all threads
+    if (sock == -1) {
+        fprintf(stderr, "Unable to open socket.\n");
+        bs->run_threads = 0;
 	return NULL;
 }
 
-/*
- * Read data from ring buffer.
- * Write data to file on disk.
- */
-void *hdd_thread_function(void *arg)
-{
-	HDD_THREAD_ARGS *args = (HDD_THREAD_ARGS *)arg;
-	RING_BUFFER *pkt_buffer = args->pkt_buffer;
+    while (bs->run_threads) {
+        this_slot = bs->buf->write_ptr;
+        if (clock_gettime(CLOCK_REALTIME, &ts) == -1) {
+            fprintf(stderr, "Net: clock_gettime returned nonzero.\n");
+            bs->run_threads = 0;
+            continue;
+        }
+        ts.tv_nsec += 10000000;     // 10 ms
+        // Wait for next buffer slot to open up for writing
+        if (sem_timedwait(&this_slot->write_mutex, &ts) == -1) continue;
 
-	RING_ITEM *this_slot = pkt_buffer->write_ptr;
-	RING_ITEM *next_slot = NULL;
-
-	int fd = open_output_file(CAPTURE_FILE);
-	ssize_t num_bytes = 0;
-
-	debug_fprintf(stderr, "Entering hard disk thread loop.\n");
-
-	/*
-	 * loop forever:
-	 *   update relevant local pointers,
-	 *   wait for next full buffer slot,
-	 *   grab current buffer slot read_mutex,
-	 *   write data from the buffer to a file,
-	 *   release the buffer slot write_mutex,
-	 *   advance read pointer to next buffer slot.
-	 */
-	while (run_hdd_thread)
-	{
-		next_slot = this_slot->next;
-
-		sem_wait(&this_slot->read_mutex);
-		num_bytes = write(fd, this_slot->data, this_slot->size);
-		sem_post(&this_slot->write_mutex);
-
-		if (num_bytes == -1)
-		{
-			perror("Unable to write packet.\n");
-			exit(1);
+        // Poll until socket has data
+        while (bs->run_threads) {
+            //printf("RX: Starting over\n");
+            FD_ZERO(&readset);
+            FD_SET(sock, &readset);
+            tv.tv_sec = 0; tv.tv_usec = 10000;      // 10 ms
+            is_ready = select(sock + 1, &readset, NULL, NULL, &tv);
+            // Start creating packet from incoming data
+            if (is_ready > 0) {
+                //printf("RX: Reading data: bufoff=%d\n", bufoff);
+                num_bytes = recv(sock, buf+bufoff, SPEAD_MAX_PACKET_SIZE, 0) + bufoff;
+                //for (i=0;i<num_bytes;i++) {
+                //    if (i % 8 == 0) printf("\n");
+                //    printf("%02x ", (uint8_t)buf[i]);
+                //}
+                //printf("\n");
+                if (num_bytes >= SPEAD_ITEM_BYTES) {
+                    i = spead_unpack_hdr(&this_slot->pkt, buf);
+                    if (num_bytes >= i + this_slot->pkt.n_items * SPEAD_ITEM_BYTES) {
+                        i += spead_unpack_items(&this_slot->pkt, buf + i);
+                        if (num_bytes >= i + this_slot->pkt.payload_len) {
+                            i += spead_unpack_payload(&this_slot->pkt, buf + i);
+                            // If there are leftovers (we read part of the next packet) copy them to the
+                            // front of buf and set bufoff
+                            //printf("RX: finished reading packet, %d/%d\n", i, num_bytes);
+                            for (bufoff=0; bufoff < num_bytes - i; bufoff++) {
+                                buf[bufoff] = buf[i+bufoff];
 		}
-		else
-		{
-			debug_fprintf(stderr, "[hdd thread] Wrote %ld bytes.\n", num_bytes);
+                            break;
 		}
-
-		this_slot = next_slot;
-	} // end while
-
-	debug_fprintf(stderr, "Exiting hard disk thread loop.\n");
-
-	close(fd);
-
+                    }
+                    bufoff = 0;  // bufoff is reset whenever there are enough data for a packet, but no match
+                }
+            } else if (is_ready < 0) {
+                if (errno == EINTR) continue;
+                fprintf(stderr, "Unable to receive packets.\n");
+                bs->run_threads = 0;
+            }
+        }
+        // Mark this slot ready for readout if we broke out of loop (not if run_threads went down)
+        if (bs->run_threads) {
+            //printf("RX: Posting packet\n");
+            sem_post(&this_slot->read_mutex);
+            bs->buf->write_ptr = this_slot->next;
+        }
+    }
+    close(sock);
 	return NULL;
 }
 
-/*
- * Bind to a port and listen for incoming data.
- */
-int setup_network_listener()
-{
+socket_t setup_network_listener(short port) {
+    /* Open up a UDP socket on the specified port for receiving data */
 	int sock = -1;
 	struct sockaddr_in my_addr; // server's address information
-	int ret = 0;
 
 	// create a new UDP socket descriptor
 	sock = socket(PF_INET, SOCK_DGRAM, 0);
-	if (sock == -1)
-	{
-		perror("Unable to set socket descriptor.\n");
-		exit(1);
-	}
+    if (sock == -1) return -1;
 
 	// initialize local address struct
 	my_addr.sin_family = AF_INET; // host byte order
-	my_addr.sin_port = htons(LISTEN_PORT); // short, network byte order
+    my_addr.sin_port = htons(port); // short, network byte order
 	my_addr.sin_addr.s_addr = htonl(INADDR_ANY); // listen on all interfaces
 	memset(my_addr.sin_zero, 0, sizeof(my_addr.sin_zero));
 
 	// bind socket to local address
-	ret = bind(sock, (SA *)&my_addr, sizeof(my_addr));
-	if (ret == -1)
-	{
-		perror("Unable to bind to socket.\n");
-		exit(1);
-	}
+    if (bind(sock, (SA *)&my_addr, sizeof(my_addr)) == -1) return -1;
 
 	// prevent "address already in use" errors
 	const int on = 1;
-	ret = setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, (void *)&on, sizeof(on));
-	if (ret == -1)
-	{
-		perror("setsockopt");
-		exit(1);
-	}
+    if (setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, 
+            (void *)&on, sizeof(on)) == -1) return -1;
 
-	debug_fprintf(stderr, "Listening on IP address %s on port %i\n", inet_ntoa(my_addr.sin_addr), LISTEN_PORT);
-
 	return sock;
 }
-
-/*
- * Open a file on disk for writing ring buffer data.
- */
-int open_output_file(const char *path)
-{
-	int flags = O_CREAT|O_TRUNC|O_WRONLY;
-	mode_t mode = S_IREAD | S_IWUSR;
-	int fd = -1;
-
-	fd = open(path, flags, mode);
-	if (fd == -1)
-	{
-		perror("Unable to open capture file.\n");
-		exit(1);
-	}
-
-	return fd;
-}
-
-/*
- * Ctrl-C handler.
- */
-void cleanup(int signal)
-{
-	run_net_thread = 0;
-}
